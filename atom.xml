<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://g-h-li.github.io/GH-Li.github.io/</id>
    <title>GH-Li的分享</title>
    <updated>2021-05-22T08:08:39.401Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://g-h-li.github.io/GH-Li.github.io/"/>
    <link rel="self" href="https://g-h-li.github.io/GH-Li.github.io/atom.xml"/>
    <subtitle>I&apos;m going to live every minute of my life!</subtitle>
    <logo>https://g-h-li.github.io/GH-Li.github.io/images/avatar.png</logo>
    <icon>https://g-h-li.github.io/GH-Li.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, GH-Li的分享</rights>
    <entry>
        <title type="html"><![CDATA[操作系统复习简要笔记]]></title>
        <id>https://g-h-li.github.io/GH-Li.github.io/post/cao-zuo-xi-tong-fu-xi-jian-yao-bi-ji/</id>
        <link href="https://g-h-li.github.io/GH-Li.github.io/post/cao-zuo-xi-tong-fu-xi-jian-yao-bi-ji/">
        </link>
        <updated>2021-05-22T05:56:45.000Z</updated>
        <content type="html"><![CDATA[<h2 id="基本特征">基本特征</h2>
<ul>
<li>并发（进程、线程；与并行的区别）</li>
<li>共享（互斥共享、同时共享）</li>
<li>虚拟（时分复用、空分复用）</li>
<li>异步</li>
</ul>
<h2 id="基本功能">基本功能</h2>
<ul>
<li>进程管理：进程管理、同步、通信、死锁、调度策略</li>
<li>内存管理：内存分配、地址映射、虚拟内存等</li>
<li>文件管理：文件读写管理</li>
<li>设备管理：设备分配、处理、缓冲管理、虚拟设备等</li>
</ul>
<h2 id="进程管理">进程管理</h2>
<ul>
<li>进程：资源分配的基本单位。进程概念的具体实现：进程控制块PCB（描述进程的基本信息和运行状态，管理进程操作即管理PCB）</li>
<li>线程：独立调度的基本单位。一个进程中存在多个线程，共享进程资源</li>
</ul>
<h3 id="进程管理实现细则">进程管理实现细则</h3>
<h4 id="1-进程状态">1、进程状态</h4>
<ul>
<li>
<p>就绪（ready）：等待被调度</p>
</li>
<li>
<p>运行（running）</p>
</li>
<li>
<p>阻塞（waiting）：等待资源<br>
<img src="https://g-h-li.github.io/GH-Li.github.io//post-images/1621664272395.png" alt="" loading="lazy"></p>
<h4 id="2-进程调度算法保证吞吐量和周转时间">2、进程调度算法：保证吞吐量和周转时间</h4>
<ul>
<li>先来先服务</li>
<li>非抢占式短作业优先</li>
<li>最短剩余时间优先（抢占式短作业优先）</li>
<li>时间片轮转：基于先来先服务的原则构建任务执行顺序；关键点时间片大小</li>
<li>优先级调度：随着时间推移，增加进程优先级</li>
<li>多级反馈队列：上层队列优先级大于下层队列，执行时间片小于下层队列<br>
<img src="https://g-h-li.github.io/GH-Li.github.io//post-images/1621664927262.png" alt="" loading="lazy"></li>
</ul>
<h4 id="3-进程同步">3、进程同步</h4>
<ul>
<li>P、V操作</li>
<li>管程</li>
<li>常见同步问题：哲学家进餐、读者-写者、理发</li>
</ul>
<h4 id="4-进程通信">4、进程通信</h4>
<ul>
<li>管道（只支持半双工通信即单向交替传输；只能再父子进程或者兄弟进程中使用）</li>
<li>FIFO，也称命名管道，去除了只能在父子进程使用的限制</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享存储</li>
<li>Sockets（套接字）：不同机器</li>
</ul>
</li>
</ul>
<h2 id="死锁">死锁</h2>
<h3 id="死锁必要条件">死锁必要条件：</h3>
<ul>
<li>互斥：资源只存在两种状态：被分配状态和可用状态</li>
<li>占有和等待：已经得到某个资源的进程可以继续请求其他资源</li>
<li>不可抢占：资源无法抢占式获得</li>
<li>环路等待：有两个及以上进程线程环路，等待其他进程释放资源</li>
</ul>
<h3 id="解决死锁方法">解决死锁方法：</h3>
<ul>
<li>鸵鸟策略：忽略死锁</li>
<li>死锁检测和死锁恢复
<ul>
<li>死锁检测：检测环路、检测资源使用情况</li>
<li>死锁恢复：kill进程、rollback进程、抢占资源</li>
</ul>
</li>
<li>死锁预防：破坏四个必要条件
<ul>
<li>虚拟多个资源，破坏互斥</li>
<li>一次性请求所有资源，破坏占有等待</li>
<li>抢占式获取，破坏不可抢占</li>
<li>给资源编号，按照顺序进行资源请求，破坏环路等待</li>
</ul>
</li>
<li>死锁避免（银行家算法）</li>
</ul>
<h2 id="内存管理">内存管理</h2>
<p>内存管理一般采用虚拟内存机制，即分配虚拟内存地址，虚拟内存地址与实际内存地址存在映射关系；存在三种分配体系：分页式、分段式、段页式。</p>
<h3 id="分页式">分页式</h3>
<p>分页式结构一般为页表-页；通过虚拟地址的一段查询页表得到页，一般将真正需要的数据所在页或段调入实际内存中，因此存在页面置换算法。</p>
<h4 id="页面置换算法">页面置换算法</h4>
<ul>
<li>最长时间不被访问：理论最佳，无法实现，因为无法知道某页面多长时间不再被访问</li>
<li>最近最久未使用：置换内存中最近最久未使用的页面，使用链表维护，代价较大</li>
<li>最近未使用：每个页面有两个状态位：R（表示被访问），M（表示被修改）；优先换出R=0，M=1的页面</li>
<li>先进先出：置换最先进入的页面</li>
<li>第二次机会算法：改进先进先出，提供第二次机会；如果老页面的R位为0，直接置换；如果为1，置0，并把页面插入链表尾部</li>
<li>时钟：改进第二次机会算法，采用循环链表</li>
</ul>
<h3 id="分段式">分段式</h3>
<p>将内存分为多段，每一段可以实现动态增长，避免内存的覆盖</p>
<h3 id="段页式">段页式</h3>
<p>将内存分为多段，每一段采用分页</p>
<h2 id="设备管理">设备管理</h2>
<p>主要是磁盘管理，读取文件主要有以下几种方法：</p>
<ul>
<li>先来先服务</li>
<li>最短寻道时间（容易出现饥饿现象）</li>
<li>电梯算法Scan</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[动态规划]]></title>
        <id>https://g-h-li.github.io/GH-Li.github.io/post/dong-tai-gui-hua/</id>
        <link href="https://g-h-li.github.io/GH-Li.github.io/post/dong-tai-gui-hua/">
        </link>
        <updated>2021-04-08T23:19:30.000Z</updated>
        <content type="html"><![CDATA[<h2 id="定义">定义</h2>
<h2 id="算法描述">算法描述</h2>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HTTP与HTTPS]]></title>
        <id>https://g-h-li.github.io/GH-Li.github.io/post/http-yu-https/</id>
        <link href="https://g-h-li.github.io/GH-Li.github.io/post/http-yu-https/">
        </link>
        <updated>2021-04-06T16:06:44.000Z</updated>
        <content type="html"><![CDATA[<h2 id="http">HTTP</h2>
<h2 id="https">HTTPS</h2>
<ol>
<li><strong>是什么</strong><br>
HTTP+SSL(Security Sockets Layer)，通过SSL搭建隧道进行通信</li>
<li><strong>为什么</strong>：HTTP存在安全性问题
<ul>
<li>使用明文通信，容易被窃取</li>
<li>无法确认通信方的身份，容易伪装</li>
<li>报文可能会被修改</li>
</ul>
</li>
<li><strong>怎么办</strong><br>
为了解决http的安全性问题，https通过以下三点来实现：
<ul>
<li>加密（非对称加密与对称加密相结合）：首先使用非对称加密进行身份认证，认证成功后使用对称加密进行数据传输。</li>
<li>认证（证书机制）：TSL证书核验</li>
<li>完整性保护（报文摘要）：通过加密和认证机制进行完整性保护</li>
</ul>
</li>
<li><strong>操作流程</strong><br>
<img src="https://g-h-li.github.io/GH-Li.github.io//post-images/1617927307013.png" alt="" loading="lazy"></li>
</ol>
<h2 id="参考资料">参考资料</h2>
<ul>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E5%85%ADhttps">CS-Notes HTTPS</a></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[二分查找]]></title>
        <id>https://g-h-li.github.io/GH-Li.github.io/post/er-fen-cha-zhao/</id>
        <link href="https://g-h-li.github.io/GH-Li.github.io/post/er-fen-cha-zhao/">
        </link>
        <updated>2021-04-06T04:26:09.000Z</updated>
        <summary type="html"><![CDATA[<h2 id="注意点">注意点：</h2>
<ul>
<li><code>high=num.length -1; low=0</code></li>
<li><code>mid = (low + high) &gt;&gt; 1</code></li>
<li>循环终止条件：<code>low &lt;= high</code>，不是<code>low&lt;high</code></li>
<li>跳出循环时，<code>low != high</code></li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h2 id="注意点">注意点：</h2>
<ul>
<li><code>high=num.length -1; low=0</code></li>
<li><code>mid = (low + high) &gt;&gt; 1</code></li>
<li>循环终止条件：<code>low &lt;= high</code>，不是<code>low&lt;high</code></li>
<li>跳出循环时，<code>low != high</code></li>
</ul>
<!-- more -->
<h2 id="算法应用">算法应用</h2>
<pre><code class="language-java">//num为升序数组
public int search(int[] nums, int target){
    int low=0; int high= num.length-1; int mid;
    while(low &lt;= high){
        mid = (low+high) &gt;&gt; 1;
        if(nums[mid] == target){
            return mid;
        }else if(nums[mid] &lt; target){
            low = mid +1;
        }else{
            high = mid -1;
        }
    }
}
</code></pre>
<p>在应用过程中，会出现相关变种，变化主要存在两处：</p>
<ol>
<li>改变if-else的判断条件：如将<code>==</code>和<code>&lt;</code>这两种情况合并，以此去查找target在有序数组的上边界（<code>low</code>)，只判断<code>&lt;</code>，查找target在有序数组的下边界（<code>high</code>)。</li>
<li>改变<code>low</code>和<code>high</code>值的变化规则，如：查找循环数组分界点、查找山峰数组的山峰、</li>
</ol>
<h2 id="查找意义">查找意义</h2>
<p>查找意义的判断主要根据：mid值变化的判断式进行判定</p>
<ul>
<li><code>nums[mid] == target</code> ：查找等于target的值位置（<code>mid</code>）</li>
<li><code>nums[mid] &lt; target</code> ：查找小于taget的最大值位置（<code>high</code>)</li>
<li><code>nums[mid] &lt;= target</code>：查找大于target的最小值位置 （<code>low</code>)</li>
</ul>
]]></content>
    </entry>
</feed>